
================= GenericEffect =================

-rajouter le mode conteneur, avec donc la generation des Out/InSlot necessaire pour proxyfier les infos,
 et le getter pour savoir s'il est en mode conteneur ou pas
-rendre la classe thread-safe
-rajouter les commandes suivantes (create, delete, connect, disconnect, set)
-rajouter le chainage pere fils avec les methode pour set et get le pere
-rajouter l'interpreteur et l'encodeur
 OK -remplacer les qhash par des tableau statique
-rajouter les connection dynamique avec une liste
-rajouter le semaphore pour savoir si le render peut commencer
-remplacer la virtuelle pure render par une virtuelle implemante vide
-remplacer tout les connect etrange par un connect unifie avec plus de parametre , rappel des connects possible : stat/stat, dyn/dyn, dyn/stat, stat/dyn

-rajouter un nom
-rajouter rajouter 6 booleens pour les 6 types de connections dynamiques possibles activees ou non : AudioIn, VideoIn, ParamIn, AudioOut, VideoOut, ParamOut
-rajouter un id pour pouvoir connaitre le nom d'un module auquelle un autre est connecte( grace a la classe mapping )

LISTE DES COMMANDES:

ROUTE		CREATE			NODETYPE-ID
ROUTE		DELETE			NODEINSTANCE-ID
ROUTE		SET			INSLOT-ID VALUE
ROUTE		CONNECT-STAT/STAT	SRC-NODEINSTANCE-ID OUTSLOT-ID DST-NODEINSTANCE-ID INSLOT-ID
ROUTE		CONNECT-DYN/DYN		SRC-NODEINSTANCE-ID DST-NODEINSTANCE-ID
ROUTE		CONNECT-DYN/STAT	SRC-NODEINSTANCE-ID DST-NODEINSTANCE-ID INSLOT-ID
ROUTE		CONNECT-STAT/DYN	SRC-NODEINSTANCE-ID OUTSLOT-ID DST-NODEINSTANCE-ID
ROUTE		DISCONNECT-STAT		NODEINSTANCE-ID OUTSLOTID
ROUTE		DISCONNECT-DYN		NODEINSTANCE-ID
ROUTE		DUMP			NODEINSTANCE-ID

================ LightVideoFrame ================

-rajouter le numero de la frame
-rajouter le numero de track de la frame 
-rajouter la hauteur et la largeure

================= EffectsEngine =================

 OK -remplacer les QHash par des tableaux statiques
 OK -rajouter une methode activate & desactivate
-rajouter le patch sous forme de GenericEffect conteneur
-rendre la classe thread-safe

-rajouter un compteur pour chaque type de slot dynamiques

================= InSlot & OutSlot =================

!!!! voir si il faut permettre une seule lecture et une seule ecriture avec une methode pour
reset ou pas (ce qui permettrais au passage de savoir le status d'un InSlot (pret a la lecture ou non))

comme un tuyau, quand on le vide l'eau se barre et ne reste pas dedans.

ou sinon pouvoir definir qu'un slot et persistant ou non

 OK -les simplifiers en virant la gestion de priorite pour la deporter ailleurs
 OK -rajouter un getter pour savoir un out/inslot est connecte
 OK -rajouter un getter pour recuper l'InSlot/OutSlot auquel l'OutSlot/InSlot est connecte
 OK -rajoute la deconnection a la destruction

-rajouter un une methode pour binder un InSlot sur un InSlot deja existant et pareil pour le OutSlot
-rajouter un id et des get/set pour pouvoir recuperer l'id (pour par exemple recuperer le nom d'un parametre sur lequel on est connecte via la classe de binding)
-rajouter un parametre template pour stocker le type dans lequel le slot est contenu et des methodes pour set/get le pointeur sur le contenant.


-rajouter un setteur pour setter une deleguate a appeler pour generer la commande quand un InSlot recoit une modification ou un connection/deconnection
-rajouter une methode d'ecriture qui ne spauwn pas une commande (donc qui n'appelle pas la deleguate)


(-rajouter les constructeur par copy et operateur = en private pour empecher leur utilisation)


-truc que en fait je ferais pas -> -rajouter le using dans le template pour forcer le type sur lequel on template a posseder
la methode get default value
===> a la place : faire en sorte que les types sur lesquelles sont templates mes In/OutSlot s'initialisent avec une valeur par defaut quand on leur assigne 0

================ Classe de Binding ================

================ Classe de commande ================

================ Classe de render ================

================ Classe d'automation ================
